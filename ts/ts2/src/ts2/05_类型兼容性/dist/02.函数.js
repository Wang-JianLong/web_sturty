var x1 = function (a) { return 1; };
var y1 = function (b, s) { return 2; };
y1 = x1; // OK
// x1 = y1; // Error
console.log(y1(1, 'a')); // 1 实际是x1了
/*
要查看x是否能赋值给y，首先看它们的参数列表。
x的每个参数必须能在y里找到对应类型的参数。
注意的是参数的名字相同与否无所谓，只看它们的类型。
这里，x的每个参数在y中都能找到对应的参数，所以允许赋值
例子y = x中那样。 原因是忽略额外的参数在JavaScript里是很常见的
*/
// 类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型
var x2 = function (a, b) { return ({ name: 'Alice' }); };
var y2 = function (b) { return ({ name: 'Alice', location: 'Seattle' }); };
x2 = y2; // OK
// y2 = x2; // Error, because x() lacks a location property
/*
当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。
这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，
但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。
// 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。
//


比较函数兼容性的时候，可选参数与必须参数是可互换的。
源类型上有额外的可选参数不是错误，
目标类型的可选参数在源类型里没有对应的参数也不是错误。

当一个函数有剩余参数时，它被当做无限个可选参数。

这对于类型系统来说是不稳定的，
但从运行时的角度来看，可选参数一般来说是不强制的，
因为对于大多数函数来说相当于传递了一些undefinde
*/ 
